(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{205:function(e,t,a){"use strict";a.r(t);var o=a(0),n=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("IE warning ---")]),e._v(" "),a("h3",{attrs:{id:"setting-the-stage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setting-the-stage","aria-hidden":"true"}},[e._v("#")]),e._v(" Setting the stage")]),e._v(" "),a("p",[e._v("3D transformations allow us to take an existing 2D element on our page and manipulate it in 3D space. That much you probably already knew. The 3D space that we move elements around within - that can be defined on the element itself or on a containing element. That bit I find strange. Personally I prefer setting the 'space' on a containing element, that way the children we add will all act as you'd expect. If we were to set up each 3D element with it's own properties we're going to end up with a lot of mismatching perspectives or a lot of repetition in trying to keep everything in tune. That may be what you're after but I'll be sticking with a containing element. So let's create our stage!")]),e._v(" "),a("div",{staticClass:"language-css extra-class"},[a("pre",{pre:!0,attrs:{class:"language-css"}},[a("code",[a("span",{pre:!0,attrs:{class:"token selector"}},[e._v("#stage")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" \n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v("-webkit-perspective")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" 1200px"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" \n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v("-moz-perspective")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" 1200px"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" \n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v("-ms-perspective")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" 1200px"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" \n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v("perspective")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" 1200px"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" \n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v("-webkit-perspective-origin")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" 75% 75%"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" \n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v("perspective-origin")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" 75% 75%"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" \n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v(" \n")])])]),a("p",[e._v("Fairly simple, we only need to set two properties (in addition to any positioning / size properties to make it fit within a page). "),a("code",[e._v("perspective")]),e._v(" sets the distance of the scene from the viewer, like setting the focal length of a camera. "),a("code",[e._v("perspective-origin")]),e._v(" changes the position of the vanishing point. It defaults to the middle (50% 50%) but can be set anywhere we want using any of the distance units, percentage, or left / right / top / bottom / center. CODEPEN moving the perspective origin and slider for perspective: --- ###Moving in 3D Now we have that set up, lets put an element into it:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<div id="stage"> <div class="element"></div> </div> \n')])])]),a("p",[e._v("We can affect 3D manipulations through the "),a("code",[e._v("transform")]),e._v(" property. This property takes both 2D values (rotate, translate, scale, and skew) and 3D values (rotate, translate, and scale) so there is some overlap but we'll focus on the 3D set. In full they are: * translateX( 100px ) * translateY( 100px ) * translateZ( 100px ) * scaleX( 1 ) * scaleY( 2 ) * scaleZ( 3 ) * rotateX( 15deg ) * rotateY( 30deg ) * rotateZ( 45deg ) * rotate3d( 1, 2, 3, 45deg ) We also have shorthand versions: * translate3d( 100px, 100px, 100px ) * scale3d( 1, 2, 3 ) These can all be applied to a single "),a("code",[e._v("transform")]),e._v(" property: "),a("code",[e._v("selector { transform: translateX( 50px ) translateY( 50px ) scaleX( 1.5 ) rotateY(45deg) rotateX(10deg); }")]),e._v(" "),a("a",{attrs:{href:"http://codepen.io/ijmccallum/pen/PqbLaN",target:"_blank",rel:"noopener noreferrer"}},[e._v("CP"),a("OutboundLink")],1),e._v("? Take note that the order, specifically when rotation is involved, does matter. With scaling and translation this doesn't have such a big impact on the final result, but the rotation is complex enough to deserve it's own section! ###Rotation in 3D When a "),a("code",[e._v("transform")]),e._v(" is being applied to an element, each value will be applied in order from left to right. The example below should clearly show this effect (plus I've used it to introduce a working example of "),a("code",[e._v("rotate3d")]),e._v("). The two panels to the left have exactly the same rotation values being applied, the only difference is the order. "),a("code",[e._v(".one { transform: rotateY( 45deg ) rotateZ( 90deg ); } .two { transform: rotateZ( 90deg ) rotateY( 45deg ); } .three { transform: rotate3d( 0, 1, 2, 90deg ); }")]),e._v(" "),a("a",{attrs:{href:"http://codepen.io/ijmccallum/pen/mJOQyZ",target:"_blank",rel:"noopener noreferrer"}},[e._v("INSERT CODEPEN EXAMPLE"),a("OutboundLink")],1),e._v(" * "),a("code",[e._v(".one")]),e._v(" The Y rotation is applied first (while the Y axis points up), then the Z rotation is applied (after it's axis has been moved 45Deg) * "),a("code",[e._v(".two")]),e._v(" The Z rotation is applied (while it's axis point straight out at us), then the Y rotation is applied (which now points out to the right and as a result makes the face 'bow' to us). * "),a("code",[e._v(".three")]),e._v(" The first three arguments are context dependent vectors that define an axis around which we can rotate the element by the angle defined in the last argument... what? If you're like me then those vectors on "),a("code",[e._v(".three")]),e._v(" might not make immediate sense, but hopefully the diagram below will clear it up a bit! Our 'custom' axis starts at the origin (which defaults to the middle of our element) and extends out past a point in 3d space. Our 3 vectors are just the (x, y, z) coordinates of that point. "),a("img",{attrs:{src:"http://www.delphicdigital.com/Uploads/Gallery/blog/2015/css3d/rotate3d-vector.png",alt:"axis vector from origin to x=2, y=3, z=5"}}),e._v(" "),a("a",{attrs:{href:"http://www.intmath.com/vectors/7-vectors-in-3d-space.php",target:"_blank",rel:"noopener noreferrer"}},[e._v("source"),a("OutboundLink")],1),e._v(" - NEED TO REDO, orientation wrong (y should be up, x to the right, and z towards us) So the three individual rotation properties are really just short hand for the relevant axis vectors in "),a("code",[e._v("rotate3d")]),e._v(": "),a("code",[e._v("rotateX( 90deg )")]),e._v(" == "),a("code",[e._v("rotate3d( 1, 0, 0, 90deg )")]),e._v(" "),a("code",[e._v("rotateY( 90deg )")]),e._v(" == "),a("code",[e._v("rotate3d( 0, 1, 0, 90deg )")]),e._v(" "),a("code",[e._v("rotateZ( 90deg )")]),e._v(" == "),a("code",[e._v("rotate3d( 0, 0, 1, 90deg )")]),e._v(" ###Changing the origin We can also set the location of the origin point for each element, this will affect every translation property. Unfortunately we can't position it in 3D space - we can only move it around the 2d plane of the element in question, but if you're looking to set an origin that isn't easily accessible in this way you should probably be working with some modelling software like "),a("a",{attrs:{href:"https://www.blender.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Blender"),a("OutboundLink")],1),e._v(" (or "),a("a",{attrs:{href:"http://www.autodesk.com/products/maya/overview",target:"_blank",rel:"noopener noreferrer"}},[e._v("Maya"),a("OutboundLink")],1),e._v(" if you've got cash to burn). The (very simple) example below shows different origins in the first two elements. The third was an experiment to see if it was possible to set the origin, translate the element, then move the origin... it's not. "),a("code",[e._v(".one { transform-origin: top left; transform:rotateY(45deg); } .two { transform-origin: top center; transform:rotateY(45deg); } .three { transform-origin: top right; transform:rotateY(45deg); transform-origin: top left; }")]),e._v(" "),a("a",{attrs:{href:"http://codepen.io/ijmccallum/pen/XbNGLo",target:"_blank",rel:"noopener noreferrer"}},[e._v("CODEPEN!"),a("OutboundLink")],1),e._v(" --- ###Backface visibility This is a simple but important property. If an element has been flipped we can define whiter the back should be visible (it will show a mirror image of the front) or not. "),a("a",{attrs:{href:"http://codepen.io/ijmccallum/pen/YXpMpW",target:"_blank",rel:"noopener noreferrer"}},[e._v("codepen"),a("OutboundLink")],1),e._v(" --- ###Transforming children "),a("code",[e._v("transform-style")]),e._v(" Allows us to set how we want transformations to apply to the children of any elements that we are manipulating in 3D. For example, in the codepen example above the letters 'X', 'Y' and the number on each plane are children of elements that have been rotated in 3D. "),a("code",[e._v("transform-style")]),e._v(" has not been set for them so they default to "),a("code",[e._v("flat")]),e._v(" which means they have no 3D context, they are applied to their parent element in the same way as usual and are then just taken along for the ride when their parent moves in space. But If we set "),a("code",[e._v("transform-style: preserve-3d;")]),e._v(" on an element then it's (direct) children get to move in space too. Here's an example of the difference: "),a("a",{attrs:{href:"http://codepen.io/ijmccallum/pen/qdqgJo",target:"_blank",rel:"noopener noreferrer"}},[e._v("CODEPEN!"),a("OutboundLink")],1),e._v(" On the left each element from the biggest black panel down have "),a("code",[e._v("transform-style: flat;")]),e._v(" and on the right "),a("code",[e._v("transform-style: preserve-3d;")]),e._v(". Each child panel on "),a("em",[e._v("both")]),e._v(" sides has a z transform but, as you can see (unless you're using IE or some other older browser) only those who's parents have the "),a("code",[e._v("preserve-3d")]),e._v(" option get to play. One final note on this, we've got some vendor prefixes you might want to be aware of: "),a("code",[e._v("-webkit-transform-style: preserve-3d; -moz-transform-style: preserve-3d; -ms-transform-style: preserve-3d; transform-style: preserve-3d;")]),e._v(" --- All the sections you've just read through (assuming you didn't skip them!) cover the mechanics of 3D manipulation in CSS. Working with this stuff will only ever result in simple effects but it's a foundation that you should know before building on. Also, simple effects might be just what's needed in your next project! For the more complex models, animations and effects we're far better off looking into tools like "),a("a",{attrs:{href:"http://tridiv.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("trivdiv"),a("OutboundLink")],1),e._v(" or even something like WebGL.")])])}),[],!1,null,null,null);t.default=n.exports}}]);